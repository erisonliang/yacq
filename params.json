{"name":"Yacq","tagline":"Yet Another Compilable Query Language for .NET","body":"ï»¿<!-- -*- mode: markdown; encoding: utf-8; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*- -->\r\n# Welcome\r\n\r\nYACQ <small>(pronounced as yacc)</small> is an **application-embeddable programming language for querying and scripting**, runs on .NET platform.\r\n\r\n## Features\r\n\r\nYACQ is a library that provides run-time scripting and querying for .NET applications. YACQ has the following features mainly:\r\n\r\n* **Extension of Expression Trees API**. YACQ is based on [Expression Trees API](http://msdn.microsoft.com/library/bb397951.aspx), a standard feature and one of basis of LINQ ecosystem. Since YACQ extends this and uses as its native syntax tree, YACQ fits with standard and other LINQ query providers.\r\n* **Language Services**. YACQ can construct expression trees from source code string by [Parseq](https://github.com/linerlock/parseq), a monadic parser combinator. There are no way to construct expression trees from string in run-time <small>(without external processes)</small> in vanilla environments. You can modify and extend the grammar of YACQ.\r\n* **LINQ Support**. YACQ contains wrapper class of querying interfaces such as `IQueryable<T>`. You can use (standard) query operators along with YACQ, in order to specify selectors, predicates, and other lambdas by code strings. Moreover, YACQ supports [Rx (Reactive Extensions) and Ix (Interactive Extensions)](https://rx.codeplex.com/).\r\n* **Extended Type System**. YACQ not only can access to almost of .NET types, but also can extend the type system of .NET transparently. When you access to extension members, YACQ transforms to expression which is composed only of real member accesses. In short, YACQ can extend types without pollution of expression trees.\r\n* **Type Generator**. Since the power of Expression Trees API, YACQ can compile codes to delegate or emits to static method builders, furthermore, YACQ also can define types with instance and static members, and output assemblies.\r\n* **Expression Tree Serializer**. In vanilla environments, expression trees are not serializable. YACQ provides proxy types to support serialization. Proxy type describes the contents of the serialized expression tree more detailed and concisely than default `Expression.ToString()` outputs.\r\n\r\n## Usages\r\n\r\nConstruct an expression tree from YACQ code string.\r\n\r\n```c#\r\nExpression expr =\r\n    YacqServices.Parse(\"(+ 1 2 3)\");\r\n    // same as ((1 + 2) + 3)\r\n```\r\n\r\nLambdas which has only one argument can construct easily by the helper method.\r\n\r\n```c#\r\nExpression<Func<string, string>> lambda =\r\n    YacqServices.ParseFunc<string, string>(\"it.(ToUpper).(Replace 'FOO' 'bar')\");\r\n    // same as (string it) => it.ToUpper().Replace(\"foo\", \"bar\")\r\n```\r\n\r\nConstructed lambdas can compile and evaluate by standard feature in run-time.\r\n\r\n```c#\r\nFunc<string, string> func = lambda.Compile();\r\nfunc(\"foooo\"); // returns \"barOO\"\r\n```\r\n\r\nYou can use YACQ in LINQ queries.\r\n\r\n```c#\r\nvar query = Enumerable.Range(1, 100)\r\n    .Yacq()\r\n    .Where(\"(== (% it 3) 0)\")\r\n    .GroupBy(\"(/ it 10)\")\r\n    .Select(\"it.(Average)\")\r\n    .OrderByDescending(\"it\");\r\n\r\n// Same as:\r\nEnumerable.Range(1, 100)\r\n    .Where(it => it % 3 == 0)\r\n    .GroupBy(it => it / 10)\r\n    .Select(it => it.Average())\r\n    .OrderByDescending(it => it);\r\n```\r\n\r\nYACQ provides expression trees serializer. In vanilla environments, they are not serializable.\r\n\r\n```c#\r\nstring xml = YacqServices.SaveText(lambda);\r\nExpression lambda2 = YacqServices.LoadText(xml);\r\n```\r\n\r\nYou can construct complex expression trees with YACQ-extended Expression Trees system.\r\n\r\n```c#\r\nExpression expr2 = YacqExpression.TypeCandidate(typeof(Enumerable))\r\n    .Method(\"Range\", Expression.Constant(1), Expression.Constant(100))\r\n    .Method(\"Reverse\")\r\n    .Method(\"Take\", Expression.Constant(10))\r\n    .Method(\"Sum\")\r\n    .Reduce();\r\n\r\n// Same as:\r\nExpression.Call(typeof(Enumerable), \"Sum\", null,\r\n    Expression.Call(typeof(Enumerable), \"Take\", new [] { typeof(int), },\r\n        Expression.Call(typeof(Enumerable), \"Reverse\", new [] { typeof(int), },\r\n            Expression.Call(typeof(Enumerable), \"Range\", null, Expression.Constant(1), Expression.Constant(100))\r\n        ), Expression.Constant(10)));\r\n```\r\n\r\nAlthough the main use of YACQ is to embed in other applications, YACQ also can use in standalone. Complier frontend and REPL environment are bundled.\r\n\r\n## Get Started\r\n\r\nTo use YACQ, you have to refer `Yacq.dll` by your application. There are some way to get the system:\r\n\r\n* **[Install NuGet package](http://nuget.org/packages/Yacq)**: If you only need the library, you can get and install it via NuGet.<br />\r\n```\r\nPM> Install-Package Yacq\r\n```\r\n* **[Download binary archive](http://yacq.net/download)**: You can download the binary archive. This contains all libraries, executables, and documents. If you want compiler frontend or REPL environment, please download this.\r\n* **[Download source code in GitHub](https://github.com/takeshik/yacq)**: You can get the source codes in GitHub.\r\n    * **Clone the repository**: You can clone the Git repository.<br />\r\n    ```\r\n    % git clone git://github.com/takeshik/yacq.git\r\n    ```\r\n    * **Download snapshot**: Snapshot archive of the repository is also available ([.tar.gz](https://github.com/takeshik/yacq/tarball/master) | [.zip](https://github.com/takeshik/yacq/zipball/master)).\r\n\r\n## Prerequisites\r\n\r\n* Target Framework:\r\n    * .NET Framework 4 or later\r\n    * Silverlight 5\r\n    * Mono 2.10 or later\r\n* Library Dependencies\r\n    * Reactive Extensions ([Rx-Main](http://nuget.org/packages/Rx-Main), [Rx-Providers](http://nuget.org/packages/Rx-Providers))\r\n    * Interactive Extensions ([Ix\\_Experimental-Main](http://nuget.org/packages/Ix_Experimental-Main), [Ix_Experimental-Providers](http://nuget.org/packages/Ix_Experimental-Providers))\r\n    * [Parseq](http://nuget.org/packages/Parseq)\r\n\r\n## Licensing\r\n\r\nCopyright &copy; 2011-2013 Takeshi KIRIYA (aka takeshik) <small>([Web](http://www.takeshik.org/) | [Mail](mailto:takeshik_AT_yacq_DOT_net) | [GitHub](https://github.com/takeshik) | [Twitter](https://twitter.com/takeshik)</small>), All rights reserved.\r\n\r\nYACQ is [Free Software](http://www.gnu.org/philosophy/free-sw.html). Its source codes, binaries, and all other resources are licensed under the [MIT License](https://github.com/takeshik/yacq/blob/master/LICENSE.txt).\r\n<!-- vim:set ft=markdown fenc=utf-8 ts=4 sw=4 sts=4 et: -->\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}